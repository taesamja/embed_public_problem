
This directory is intended for PlatformIO Test Runner and project tests.

Unit Testing is a software testing method by which individual units of
source code, sets of one or more MCU program modules together with associated
control data, usage procedures, and operating procedures, are tested to
determine whether they are fit for use. Unit testing finds problems early
in the development cycle.

More information about PlatformIO Unit Testing:
- https://docs.platformio.org/en/latest/advanced/unit-testing/index.html

“공개과제-2” 코드를 직접 읽고, 고치고, 변형까지 해 볼 수 있도록 단계별로 구조화했습니다. 각 단계마다 “왜 그렇게 했는지(의도)”를 함께 적었습니다.

1) 무엇을 만들고 있나(요구사항 요약)
- 전원 또는 SW3로 초기화:
  - FND: 88을 1초 ON, 1초 OFF를 2회 보여준 뒤, 50을 표시 유지.
  - RGB: G 1초 → B 1초를 2회 반복한 다음 R을 켠 상태로 대기.
  - 초기화 중에는 스위치 입력을 무시. 
- 동작1(감소): SW1을 1초 이상 누르고 있는 동안
  - FND 숫자를 0.5초마다 1씩 감소, RGB는 B를 0.5초 켜고 0.5초 끄는 점멸 반복.
  - 동작 중에는 SW2·SW3은 무시. SW1을 떼면 현재 숫자 유지 + R 켬.
  - 00에 도달한 뒤에도 1초 더 누르면 동작3 수행. 
- 동작2(증가): SW2를 1초 이상 누르고 있는 동안
  - FND 숫자를 0.5초마다 1씩 증가, RGB는 G를 0.5초 켜고 0.5초 끄는 점멸 반복.
  - 동작 중에는 SW1·SW3은 무시. SW2를 떼면 현재 숫자 유지 + R 켬.
  - 99에 도달한 뒤에도 1초 더 누르면 동작3 수행. 
- 동작3(특수 표시):
  - FND는 00을 1초, 99를 1초 “2회 반복”(00→99→00→99).
  - RGB는 R 1초 → G 1초 → B 1초 → 1초 OFF.
  - 수행 중 모든 스위치 무시, 완료 후 “50 표시 + R 켬” 상태로 복귀. 

2) 하드웨어 개념 한 줄 이해
- RGB LED 모듈: 공통 애노드 방식 → LOW가 ON, HIGH가 OFF입니다. 그래서 setRGB에서 true면 LOW(켜짐)로 씁니다.
- 2자리 FND + 74LS47(BCD→7세그 디코더): BCD_A~D로 0~9를 주면 74LS47이 세그먼트를 구동합니다.
- 두 자리 FND는 자리 선택(DIG_TENS, DIG_ONES)을 아주 빠르게 번갈아 켜는 “시분할(멀티플렉싱)”로 둘 다 켜 보이게 합니다.

3) 핀 매핑과 기본 규칙
- 스위치 SW1·SW2·SW3: INPUT_PULLUP 사용(눌림=LOW).
- RGB: 공통 애노드(LOW=ON). R/G/B를 켤 때는 LOW, 끌 때는 HIGH.
- FND 자리 선택: 공통 애노드 가정으로 HIGH=해당 자리 ON.

4) 전역 변수와 그 의미
- currentNumber: 지금 FND에 보여줄 값(초기화 후 50).
- isBusy: 초기화/동작3 동안 true → 이때는 스위치 입력을 무시(요구사항 반영).
- pressStart1/2: 롱프레스(1초 이상) 판정을 위한 “눌리기 시작한 시간”.
- lastSW1/2/3: 직전 스위치 상태(눌렀다-뗀 순간 감지용).

5) 함수별 역할과 의도
- setRGB(r,g,b): 공통 애노드에 맞게 LOW=ON, HIGH=OFF로 출력.
- displayDigit(n): 0~9 값을 74LS47 BCD 입력으로 전송.
- displayNumber(tens,ones,ms): 두 자리를 ms 동안 번갈아 켜서 “두 자리”처럼 보이게 유지.
  - 십의 자리 3ms → 일의 자리 3ms → 반복. 너무 길면 반응이 느려지고, 너무 짧으면 어두워집니다.
- showCurrent(ms): 현재 값(currentNumber)을 잠깐(ms)만 보여 주고 반환. loop가 자주 돌아 버튼/타이밍을 빨리 처리하려는 의도입니다.
- performInitProcess():
  - 88 ON/OFF ×2 → 50 표시 유지, (G→B)×2 → R ON, 완료 후 50+R. 수행 중 스위치 무시. 
- performAction1():
  - SW1을 누르고 있는 동안에만 실행되는 “블로킹 루프”.
  - 0.5초마다 숫자 1 감소, B 0.5초 점멸. SW1을 떼면 즉시 종료(현재 숫자 유지+R).
  - 숫자가 0이 되면 그 시각을 기록하고, 계속 1초 더 누르고 있으면 동작3으로 진입. 
- performAction2():
  - SW2를 누르고 있는 동안에만 실행되는 “블로킹 루프”.
  - 0.5초마다 숫자 1 증가, G 0.5초 점멸. SW2를 떼면 즉시 종료(현재 숫자 유지+R).
  - 99 도달 후 1초 더 누르면 동작3. 
- performAction3():
  - 00 1초 → 99 1초를 “두 번 반복”. RGB는 R→G→B→OFF를 1초씩. 끝나면 50 + R로 복귀. 

6) 메인 흐름(loop) 쉽게 따라가기
- 매 loop에서 showCurrent(8)로 화면을 8ms만 유지 → 버튼·타이밍 처리가 빠름.
- SW3: 눌렀다 떼면(엣지) 언제든 초기화(단, isBusy일 때는 무시).
- SW1, SW2: 각각 1초 이상 “누르고 있을 때”만 동작1, 동작2로 진입.
  - 진입 판단 시 현재 값이 00(또는 99)라면 동작3을 우선 실행.
- 동작1/2 안에서는 해당 버튼만 읽고 나머지 스위치는 “무시”합니다(요구사항 그대로). 

7) 타이밍(밀리초) 이해
- 롱프레스: 1000ms 이상 LOW 유지.
- 증감/점멸: 500ms 마다 한 번씩 실행.
- 동작3: 각 표시/색상 1000ms씩.
- 초기화: 88 표시/소등 각각 1000ms, G/B 각각 1000ms ×2.

8) 직접 해보는 체크 시나리오
- 전원 ON → 88 깜빡 2회 → 50 표시 + R ON인지 확인(초기화). 
- SW1을 1초 이상 누르기 → 숫자가 0.5초마다 줄고, B가 0.5초 간격으로 점멸하는지.
  - 중간에 SW1을 떼면: 그 숫자 유지 + R ON으로 복귀하는지.
  - 00 도달 후 계속 1초 더 누르면: 00→99→00→99(각 1초) + RGB R→G→B→OFF(각 1초) 동작3 후 50+R로 돌아오는지. 
- SW2도 동일하게 99 경계에서 확인.
- 동작1 중 SW2·SW3를 눌러도 반응하지 않는지, 동작2 중 SW1·SW3도 무시되는지. 

9) 자주 틀리는 포인트와 해결 팁
- RGB가 색이 반대로 나오면: 공통 캐소드 모듈일 수 있습니다(이 코드는 공통 애노드 전제). HIGH/LOW 논리를 반대로 바꾸세요.
- FND가 너무 어둡거나 깜빡이면: displayNumber 내 delay(3)나 showCurrent(8)을 살짝 조절(예: 10~12ms)하면 밝기가 좋아집니다.
- 00/99에서 동작3이 안 들어가면: “도달 시각 기록”과 “1초 더 누름” 로직(n==0 또는 n==99 상태에서 edgeHoldStart 비교)을 점검하세요.
- 오동작/잔상: DIG_TENS/DIG_ONES 제어와 displayDigit 순서를 항상 “한 자리만 ON”인 상태로 유지하세요(두 자리 동시에 HIGH가 되지 않게).

10) 왜 이런 구조를 썼나(의도)
- 블로킹 함수 + 간단한 loop: 처음 배우는 학생이 흐름을 따라가기 쉽습니다.
  - 초기화/동작3은 “연속 연출”이라 블로킹(while/for) 편이 읽기 쉽습니다.
  - 동작1/2는 버튼을 “누르고 있는 동안만” 유지되어야 하므로 그 버튼만 감시하는 루프로 작성했습니다(다른 스위치 무시 조건을 자연스럽게 만족). 
- showCurrent(8)로 화면 유지를 짧게 맡기고 바로 반환 → 반응성(롱프레스 판정)이 좋아집니다.

11) 심화 과제(도전!)
- 비블로킹으로 바꾸기: 동작1/2도 while이 아닌 “상태 업데이트 함수”로 만들어 loop에서 조금씩만 실행(지난번에 드린 쉬운 구조 예제처럼)하면 더 매끄럽습니다.
- 디바운스 넣기: 스위치에 10~20ms 디바운스 필터를 추가해 안정화.
- 시작 숫자 바꾸기: currentNumber 초기값(50)을 다른 값으로 바꿔 보고, 초기화 시퀀스도 취향대로 변경해 보기.
- 표시 밝기 튜닝: delay와 show 시간(REFRESH)을 바꿔 최적 밝기 찾기.
